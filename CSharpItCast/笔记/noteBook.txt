1、.Net平台  .Net FrameWork框架
.Net FrameWork框架提供了一个稳定的运行环境，；来保障我们.Net平台正常的运转

2、C#语言 c sharp
编程语言，如果你想要计算机按照你说的去做，你必须说计算机能够听懂的语言。


2001年  any time any place  and on any device
任何时间任何地点都能够让用户通过任何设备获取到用户想要的数据

1997 李开复   XXX

乔布斯  windows phone====》安卓===》wp7===》 wp8======>unity3D


Unity3D 老鼠---猫
c#
JS
BOO

3、两种交互模式
C/S:要求客户的电脑上必须要安装一个客户端：qq、360、快播等.....
B/S:要求客户的电脑上只需要安装一个浏览器。


4、IDE
IDE指的就是我们的开发工具。

5、vs的学习
1)、启动VS
a、双击图标
b、调出cmd，输入 devenv

2)、解决方案、项目及类之间的关系
解决方案：公司
项目：部门
类：员工
在视图里面找解决方案资源管理器

3)、Program中的各个组成部分
引用命名空间：
京东----》京东在线商城项目---》顾客类
淘宝----》淘宝在线商城项目---》顾客类

高端霸气公司----》老赵牛X项目---》顾客类

4)、方法或者函数 
Main函数是我们程序的主入口，你写的代码如果想要被执行的话，必须写在Main函数当中。

5)、
.sln：解决方案文件，里面包含着整个解决方案的信息，可以双击运行。
.csproj:项目文件，里面包含着这个项目的信息，可以双击运行。

6、书写代码需要注意的地方：
1、代码中出现的所有标点都是英文半角 shift键快速切换中文半角和英文半角 
shift+空格 切换全角/半角
2、在c#代码中，每行代码的结束，我们都以分号结束，注意：这个分号也是英文半角的分号。
3、Console.WriteLine("要打印的内容");
   Console.ReadKey();
   1)、暂停当前程序，等待用户按下任意键继续，按下的任意键将显示在我们的控制台当中
   
7、运行程序的两种方式
1、点击绿色的启动按钮
2、使用快捷键F5
ctrl+shift+B：生成代码


8、生成解决方案
帮助我们排查语法错误。

1、注释符
1)、注销
2)、解释

2、c#的3种注释符
1)、单行注释 //
2)、多行注释 /*要注释的内容*/
3)、文档注释 /// 多用来解释类或者方法---》敲三个斜线自动生成

VS常用快捷键
Ctrl+K+D 快速对齐代码
Ctrl+j 快速弹出提示
Shift+End
Shift+Home
Ctrl+K+C 快速注释
Ctrl+K+U 快速取消注释
#Region #EndRegion 折叠冗余代码
Ctrl+R Ctrl+E 自动的生成get set


3、变量
用来在计算机当中存储数据。

孙全 开房
火车 26小时  去旅馆睡觉
孙全  一个人  单人房  308
孙全 and  girl  双人间  一张床 521
孙全 and  boy  双人间 两张床  520

存储整数100 
数据类型：整数
在内存中开辟的空间应该是整数类型 int

存储变量的语法：
变量类型 变量名;
变量名=值;

"="号：在这并不表示等于的意思，而是赋值的意思，表示把等号右边的值赋值给等号左边的变量。

声明并且给变量赋值的简写形式：
变量类型 变量名=值;

4、数据类型
1)、整数类型：int  只能存储整数，不能存储小数。
2)、小数类型：double 既能存储整数，也能存储小数，小数点后面的位数 15~16位。
3)、金钱类型：decimal：用来村粗金钱，值后面需要加上一个m.
4)、字符串类型:string,用来存储多个文本，也可以存储空，字符串类型的值需要被 双引号引来，
这个双引号必须是英文半角状态下的双引号
5)、字符类型：char,用来存储单个字符，最多、最少只能有一个字符，不能存储空。
字符类型的值需要用 单引号因起来。英文半角状态下的单引号。

5、波浪线
1)、如果你的代码中出现了红色的波浪线，意味着你的代码中出现了
语法错误。
2)、如果你的代码中出现了绿色的波浪线，说明你的代码语法并没有错误，
只不过提示你有可能会出现错误，但是不一定会出现错误。警告线

6、变量的使用规则
如果你要是用变量的话，应该要先声明再赋值再使用。


7、命名规则：
****首先要保证的就是这个变量的名字要有意义。
1 现阶段给变量起名字的时候都以字母开头
2 后面可以跟任意“字母”、数字、下划线.
注意:
1）你起的变量名不要与c#系统中的关键字重复.
2）在c#中,大小写是敏感的.  HTML
3)同一个变量名不允许重复定义(先这么认为,不严谨)

给变量起名字的时候要满足两个命名规范：
1、Camel 骆驼命名规范。要求变量名首单词的首字母要小写，其余每个单词的首字母要大写。
多用于给变量命名。
2、Pascal 命名规范：要求每个单词的首字母都要大写，其余字母小写。多用于给类或者方法命名。
HighSchoolStudent

highSchoolStudent


8、赋值运算符
=：表示赋值的意思，表示把等号右边的值，赋值给等号左边的变量。
由等号连接的表达式称之为赋值表达式。
注意:每个表达式我们都可以求解除一个定值，对于赋值表达式而言，等号左边的变量的值，
就是整个赋值表达式的值。
int number=10;

9、+号的作用
1)、连接：当+号两边有一边是字符串的时候，+号就起到连接的作用。
2)、相加：两边是数字的时候


10、占位符
使用方法：先挖个坑，再填个坑。
使用占位符需要注意的地方：
1、你挖了几个坑，就应该填几个坑，如果你多填了，没效果。
                                 如果你少填了，抛异常。
2、输出顺序：按照挖坑的顺序输出。

交换两个数
int n1=3;
int n2=20;
n1=n1-n2;
n2=n1+n2;
n1=n2-n1;
								 						
11、异常
异常是指：语法上并没有任何错误，只不过在程序运行的期间，由于某些原因出现了问题，
使程序不能再正常的运行。

接收用户输入
string name=console.ReadLine();//接收的用户的输入都是string类型的


12、转义符
转义符指的就是一个'\'+一个特殊的字符，组成了一个具有特殊意义的字符。
\n:表示换行，windows系统是\r\n
\":表示一个英文半角的双引号
\t:表示一个tab键的空格
\b:表示一个退格键，会删掉前一个字符了，放到字符串的两边没有效果。
\r\n:windows操作系统不认识\n,只认识\r\n
\\:表示一个\

@符号
1、取消\在字符串中的转义作用，使其单纯的表示为一个'\'
2、将字符串按照编辑的原格式输出

13、算数运算符
+
-
*
/
%

14、类型转换
隐式类型转换：
我们要求等号两遍参与运算的操作数的类型必须一致，如果不一致，满足下列条件会发生
自动类型转换，或者称之为隐式类型转换。
两种类型兼容
例如：int 和 double 兼容(都是数字类型)
目标类型大于源类型
例如：double > int   小的转大的


显示类型转换：
1、两种类型相兼容  int--double
2、大的转成小的  double----int
语法：
(待转换的类型)要转换的值;

总结：
自动类型转换：int---->double
显示类型转换：double--->int


20平 
20平 4  5平  

1、类型如果相兼容的两个变量，可以使用自动类型转换或者强制类型转换，
但是，如果两个类型的变量不兼容，比如 string与int或者string 与double，
这个时候我们可以使用一个叫做Convert的转换工厂进行转换。
注意：使用Convert进行类型转换，也需要满足一个条件：
面儿上必须要过的去。


2、算数运算符
++：分为前++和后++，不管是前++还是后++，最终的结果都是给这个变量加一。
区别表现表达式当中，如果是前++，则先给这个变量自身加一，然后带着这个加一后的值去参与运算。
如果是后++，则先拿原值参与运算，运算完成后，再讲这个变量自身加一。
--：同上。

3、
对于向加加或者减减这样只需要一个操作数就能完成的运算，我们称之为一元运算符。
+ - * / % 对于这些需要两个或以上才能完成运算的操作符，我们称之为二元运算符。
一元运算符的优先级要高于而元运算符。
如果在一个表达式当中，既有一元运算符，又有二元运算符，我们首先计算一元运算符。

int number=10;
int result=10 + ++number;

String和string是一个东西

4、关系运算符
>
<
>=
<=
==
!=
关系运算符是用来描述两个事物之间的关系
由关系运算符连接的表达式称之为关系表达式。
5、bool类型
在c#中我们用bool类型来描述对或者错。
bool类型的值只有两个 一个true  一个false

6、逻辑运算符
&& 逻辑与
||逻辑或
!逻辑非
又逻辑运算符连接的表达式叫做逻辑表达式

逻辑运算符两边放的一般都是关系表达式或者bool类型的值。
 5>3 &&true
 
 3>5||false
 
 ！表达式
 逻辑表达式的结果同样也是bool类型
 
 一个表达式中既有逻辑与又有逻辑或会优先算逻辑与
 
 判断闰年的逻辑表达式
 bool b =  year % 400==0 || year % 4==0 && year % 100!=0;


7、复合赋值运算符
int number=10;
+= :
number+=20;
number=number+20;
-=
number-=5;
number=number-5;
*=
number*=5;
number=number*5;
/=
%=


中级程序员 --2年 ---高级程序员---->小组组长---> 项目经理
												业务经理
												产品经理
 高级程序员
 不明觉厉
软件开发工程师



顺序结构：程序从Main函数进入，从上到下一行一行的执行，不会落下任何一行。
分支结构:if  if-else
选择结构：if else-if switch-case
循环结构：while do-while for foreach

8、
if语句：
语法：
if(判断条件)
{
	要执行的代码;
}
判断条件：一般为关系表达式或者bool类型的值。
执行过程：程序运行到if处，首先判断if所带的小括号中的判断条件，
如果条件成立，也就是返回true，则执行if所带的大括号中的代码，
如果判断条件不成立，也就是返回一个false。则跳过if结构，继续向下执行。

if结构的特点：先判断，再执行，有可能一行代码都不执行
用于一种情况的判断。


9、if-else
语法：
if(判断条件)
{
	执行的代码;
}
else
{
	执行的代码
}
执行过程：程序执行到if处，首先判断if所带的小括号中的判断条件是否成立，
如果成立，也就是返回一个true，则执行if所带的大括号中的代码，
执行完成后，跳出if-else结构。
如果if所带的小括号中的判断条件不成立，也就是返回一个false，
则跳过if语句，执行else所带的大括号中的语句，执行完成后，跳出if-else结构。

if-else特点：先判断，再执行，最少都要执行一条代码。
用于两种情况的判断

注意：else永远跟离它最近的那个if配对


10、if else-if
作用：用来处理多条件的区间性的判断。
语法：
if(判断条件)
{
	要执行的代码;
}
else if(判断条件)
{
	要执行的代码;
}
else if(判断条件)
{
	要执行的代码;
}
else if(判断条件)
{
	要执行的代码;
}
........
else
{
	要执行的代码;
}
执行过程；程序首先判断第一个if所带的小括号中的判断条件，如果条件成立，也就是返回一个true，
则执行该if所带的大括号中的代码，执行完成后，立即跳出if else-if结构。
如果第一个if所带的判断条件不成立，也就是返回一个false，则继续向下进行判断，依次的判断每一个if所带
的判断条件，如果成立，就执行该if所带的大括号中的代码，如果不成立，则继续向下判断，
如果每个if所带的判断条件都不成立，就看当前这个if else-if结构中是否存在else。
如果有else的话，则执行else中所带的代码，如果没有else，则整个 if-else if神马都不做。
else可以省略。

1、异常捕获
我们在程序中经常会出现各种各样的异常，你如果想要你的程序变得坚强一些。
在你的代码中应该经常性的使用try-catch来进行异常捕获。

哪行代码有可能出现异常，你就踹它一脚。
语法：
try
{
	可能会出现异常的代码;
	....
	...
	...
}
//try和catch之间不能有其他的代码
catch
{
	出现异常后要执行的代码;
}

执行过程:如果try中的代码没有出现异常，那么catch中的代码不会执行。
如果try中的代码出现了异常，那怕这行出现异常的代码后面还有一百行都不会执行了，
而是直接跳到catch中执行代码


2、变量的作用域
变量的作用域就是你能够使用到这个变量的范围。
变量的作用域一般从声明它的那个括号开始到那个括号所对应的结束的括号结束。
在这个范围内，我们可以访问并使用变量。超出这个范围就访问不到了


3、switch-case
用来处理多条件的定值的判断。
语法：
switch(变量或者表达式的值)
{
	case 值1:要执行的代码;
	break;
	case 值2:要执行的代码;
	break;
	case 值3:要执行的代码;
	break;
	..........
	default:要执行的代码;
	break;
}
执行过程：程序执行到switch处，首先将括号中变量或者表达式的值计算出来，
然后拿着这个值依次跟每个case后面所带的值进行匹配，一旦匹配成功，则执行
该case所带的代码，执行完成后，遇到break。跳出switch-case结构。
如果，跟每个case所带的值都不匹配。就看当前这个switch-case结构中是否存在
default，如果有default，则执行default中的语句，如果没有default，则该switch-case结构
什么都不做。

4、循环结构
while循环：
while(循环条件)
{
	循环体;
}
执行过程：程序运行到while处，首先判断while所带的小括号内的循环条件是否成立，
如果成立的话，也就是返回一个true，则执行循环体，执行完一遍循环体后，再次回到
循环条件进行判断，如果依然成立，则继续执行循环体，如果不成立，则跳出while循环。
在while循环当中，一般总会有那么一行代码，能够改变循环条件，使之终有一天不再成立，
如果没有那么一行代码能够改变循环条件，也就是循环条件永远都成立，我们称之这种循环
叫做死循环。
最简单的最常用的死循环：
while(true)
{

}

特点：先判断，再执行，有可能一遍循环都不执行。
5、break
1)、可以跳出switch-case结构。
2)、可以跳出当前循环。
break一般不单独的使用，而是跟着if判断一起使用，表示，当满足某些条件的时候，就不再循环了。

6、do-while循环。
语法：
do
{
	循环体;
}while(循环条件);
执行过程:程序首先会执行do中的循环体，执行完成后，去判断do-while循环的循环条件，
如果成立，则继续执行do中的循环体，如果不成立，则跳出do-while循环。
特点：先循环，再判断，最少执行一遍循环体。

1、*程序调试
1)、写完一段程序后，想看一下这段程序的执行过程。
2)、当你写完这段程序后，发现，程序并没有按照你想象的样子去执行。

调试方法：
1)、F11逐语句调试(单步调试)
2)、F10逐过程调试
3)、断点调试


2、for循环
语法:
for(表达式1;表达式2;表达式3)
{
	循环体;
}
表达式1一般为声明循环变量，记录循环的次数(int i=0;)
表达式2一般为循环条件(i<10)
表达式3一般为改变循环条件的代码，使循环条件终有一天不再成立(i++)。
执行过程：程序首先执行表达式1，声明了一个循环变量用来记录循环的次数，
然后执行表达式2，判断循环条件是否成立，如果表达式2返回的结果为true，
则执行循环体。当执行完循环体后，执行表达式3，然后执行表达式2继续判断循环条件是否成立，
如果成立则继续执行循环体，如果不成立，则跳出for循环。


3、int.TryParse
int.parse
尝试着将一个字符串转换成int类型。

int num;
bool b=int.TryParse("123",out num);


4、三元表达式
语法:
表达式1?表达式2:表达式3;
表达式1一般为一个关系表达式。
如果表达式1的值为true，那么表达式2的值就是整个三元表达式的值。
如果表达式1的值为false，那么表达式3的值就是整个三元表达式的值。
注意：表达式2的结果类型必须跟表达式3的结果类型一致，并且也要跟整个三元表达式的结果类型一致。

产生随机数
//1.创建能够产生随机数的对象
Random r=new Random();
//2.让产生随机数的这个对象调用方法来产生随机数
int rNumber=r.Next(1,11);//产生1-10的随机数了


1、变量类型
int double string char bool decimal
变量的使用规则：先声明再赋值最后使用
int number;
number=10;
 number=20;
Console.WriteLine(number);

2、Camel  Pascal

3、运算符
赋值运算符：=
复合赋值运算符：+= -= *= /= %=  sum+=age;  sum=sum+age;
算数运算符： + - * / % ++ --
关系运算符： > < >= <= == !=
逻辑运算符： && || !

4、c#中的语法结构
分支结构：
if if-else
选择结构：
while do-while for


5、常量
声明的常量的语法：
const 变量类型 变量名=值;//常量的值一旦被声明了就无法再被改变了
什么时候会用到常量？

6、枚举
语法：
[public] enum 枚举名
{
	值1,
	值2,
	值3,
	........
}
public:访问修饰符，可有可没有。公开的公共的，哪都可以访问。
enum：关键字，声明枚举的关键字
枚举名：要符合Pascal命名规范

枚举一般被声明在class中或命名空间中
将枚举声明到命名空间的下面，类的外面，表示这个命名空间下，所有的类都可以使用这个枚举。

枚举就是一个变量类型 ，int--double  string  decimal.
只是枚举声明、赋值、使用的方式跟那些普通的变量类型不一样。


我们可以将一个枚举类型的变量跟int类型和string类型互相转换。
枚举类型默认是跟int类型相互兼容的，所以可以通过强制类型转换的语法互相转换。
当转换一个枚举中没有的值的时候，不会抛异常，而是直接将数字显示出来。

枚举同样也可以跟string类型互相转换，如果将枚举类型转换成string类型，则直接调用ToString().
如果将字符串转换成枚举类型则需要下面这样一行代码：
	(要转换的枚举类型)Enum.Parse(typeof(要转换的枚举类型),"要转换的字符串");
如果转换的字符串是数字，则就算枚举中没有，也会不会抛异常。
如果转换的字符串是文本，如果枚举中没有，则会抛出异常。


7、所有的类型都能够转换成string类型，调用ToString()。


8、结构
可以帮助我们一次性声明多个不同类型的变量。
语法：
[public] struct 结构名
{
	成员;//字段
}
变量在程序运行期间只能存储一个值，而字段可以存储多个值。


9、数组
一次性存储多个相同类型的变量。
语法：
数组类型[] 数组名=new 数组类型[数组长度];

***数组的长度一旦固定了，就不能再被改变了

10、冒泡排序：就是将一个数组中的元素按照从大到小或者从小到大的顺序进行排列。
int[] nums={9,8,7,6,5,4,3,2,1,0}; 0 1 2 3 4 5 6 7 8 9
第一趟比较：8 7 6 5 4 3 2 1 0 9 交换了9次     i=0  j=nums.Length-1-i
第二趟比较：7 6 5 4 3 2 1 0 8 9 交换了8次     i=1  j=nums.Length-1-i
第三趟比较：6 5 4 3 2 1 0 7 8 9 交换了7次     i=2  j=nums.Length-1-i
第四趟比较：5 4 3 2 1 0 6 7 8 9 交换了6次     i=3  j=nums.Length-1-i
第五趟比较：4 3 2 1 0 5 6 7 8 9 交换了5次
第六趟比较：3 2 1 0 4 5 6 7 8 9 交换了4次
第七趟比较：2 1 0 3 4 5 6 7 8 9 交换了3次
第八趟比较：1 0 2 3 4 5 6 7 8 9 交换了2次
第九趟比较：0 1 2 3 4 5 6 7 8 9 交换了1次
for(int i=0;i<number.Length-1;i++)
{
	for(int j=0;j<nums.Length-1-i;j++)
	{
		if(nums[j]>nums[j+1])
		{
			int temp=nums[j];
			nums[j]=nums[j+1];
			nums[j+1]=temp;
		}
	}
}


11、方法
函数就是将一堆代码进行重用的一种机制。
函数的语法：
[public] static 返回值类型 方法名([参数列表])
{
	方法体；
}
public:访问修饰符，公开的，公共的，哪都可以访问。
static：静态的
返回值类型：如果不需要写返回值，写void
方法名：Pascal 每个单词的首字母都大些。其余字母小写
参数列表：完成这个方法所必须要提供给这个方法的条件。如果没有参数，小括号也不能省略。

方法写好后，如果想要被执行，必须要在Main()函数中调用。
方法的调用语法：
类名.方法名([参数]);
***在某些情况下，类名是可以省略的，如果你写的方法跟Main()函数同在一个类中，这个时候，
类名可以省略。

12、return
1、在方法中返回要返回的值。
2、立即结束本次方法。

1、我们在Main()函数中，调用Test()函数，我们管Main()函数称之为调用者，
管Test()函数称之为被调用者。
如果被调用者想要得到调用者的值：
1)、传递参数。
2)、使用静态字段来模拟全局变量。
如果调用者想要得到被调用者的值：
1)、返回值

2、
不管是实参还是形参，都是在内存中开辟了空间的。

3、方法的功能一定要单一。
GetMax(int n1,int n2) 
方法中最忌讳的就是出现提示用户输入的字眼。

4、out、ref、params
1)、out参数。
如果你在一个方法中，返回多个相同类型的值的时候，可以考虑返回一个数组。
但是，如果返回多个不同类型的值的时候，返回数组就不行了，那么这个时候，
我们可以考虑使用out参数。out参数必须要在方法中被赋值
out参数就侧重于在一个方法中可以返回多个不同类型的值。

2)、ref参数
能够将一个变量带入一个方法中进行改变，改变完成后，再讲改变后的值带出方法。
ref参数要求在方法外必须为其赋值，而方法内可以不赋值。

3)、params可变参数
将实参列表中跟可变参数数组类型一致的元素都当做数组的元素去处理。
params可变参数必须是形参列表中的最后一个元素。实参列表中只能有一个params参数


5、方法的重载
概念：方法的重载指的就是方法的名称相同给，但是参数不同。
参数不同，分为两种情况
1)、如果参数的个数相同，那么参数的类型就不能相同。
2)、如果参数的类型相同，那么参数的个数就不能相同。
***方法的重载跟返回值没有关系。

6、方法的递归
方法自己调用自己。
找出一个文件夹中所有的文件。


============飞行棋================
1、画游戏头
2、初始化地图(加载地图所需要的资源)
将整数数组中的数字变成控制台中显示的特殊字符串的这个过程 就是初始化地图
3、画地图 


4、玩游戏


游戏规则：
如果玩家A踩到了玩家B  玩家B退6格  
踩到了地雷 退6格
踩到了时空隧道 进10格
踩到了幸运轮盘 1交换位置  2 轰炸对方 使对方退6格
踩到了暂停  暂停一回合  
踩到了方块  神马都不干

Map[50]
if(map[40]==1)
{
	Console.WriteLine("◎");
}


//初始化地图   Map[6]=1
            //我用0表示普通,显示给用户就是 □
            //....1...幸运轮盘,显示组用户就◎ 
            //....2...地雷,显示给用户就是 ☆
            //....3...暂停,显示给用户就是 ▲
            //....4...时空隧道,显示组用户就 e
            int[] luckyturn = { 6, 23, 40, 55, 69, 83 };//幸运轮盘◎
            int[] landMine = { 5, 13, 17, 33, 38, 50, 64, 80, 94 };//地雷☆
            int[] pause = { 9, 27, 60, 93 };//暂停▲
            int[] timeTunnel = { 20, 25, 45, 63, 72, 88, 90 };//时空隧道e
			for(int i=0;i<luckyturn.Length;i++)
			{
				int n=luckyturn[i];
				Map[n]=1;
			}
			for(int i=0;i<landMine.Length;i++)
			{
				int n=landMine[i];
				Map[n]=1;
			}


  public static void Win()
        {
            Console.ForegroundColor = ConsoleColor.Red;
            Console.WriteLine("                                          ◆                      ");
            Console.WriteLine("                    ■                  ◆               ■        ■");
            Console.WriteLine("      ■■■■  ■  ■                ◆■         ■    ■        ■");
            Console.WriteLine("      ■    ■  ■  ■              ◆  ■         ■    ■        ■");
            Console.WriteLine("      ■    ■ ■■■■■■       ■■■■■■■   ■    ■        ■");
            Console.WriteLine("      ■■■■ ■   ■                ●■●       ■    ■        ■");
            Console.WriteLine("      ■    ■      ■               ● ■ ●      ■    ■        ■");
            Console.WriteLine("      ■    ■ ■■■■■■         ●  ■  ●     ■    ■        ■");
            Console.WriteLine("      ■■■■      ■             ●   ■   ■    ■    ■        ■");
            Console.WriteLine("      ■    ■      ■            ■    ■         ■    ■        ■");
            Console.WriteLine("      ■    ■      ■                  ■               ■        ■ ");
            Console.WriteLine("     ■     ■      ■                  ■           ●  ■          ");
            Console.WriteLine("    ■    ■■ ■■■■■■             ■              ●         ●");
            Console.ResetColor();
        }

1、面向过程-----> 面向对象

面向过程：面向的是完成这件事儿的过程，强调的是完成这件事儿的动作。

把大象塞进冰箱里
1、打开冰箱门
2、把大象塞进去，亲下大象的屁股
3、关闭冰箱门

孙全 瘦小 矮  小潘
孙全踩着小板凳打开冰箱门
孙全找翟盼盼帮忙把大象塞进冰箱里，孙全踩着板凳去亲。
孙全踩着板凳关闭冰箱门

翟盼盼  190cm  非常大力气
1、翟自己就能打开冰箱门
2、翟自己将大象塞进冰箱里，翟可以自己亲一下。
3、翟自己关闭冰箱门

如果我们用面向过程的思想来解决这件事儿，当执行这件事的人的不同的时候，
我们需要为每个不同的人量身定做解决事情的方法。


面向对象：找个对象帮你做事儿。
把大象塞进冰箱里
我们把冰箱作为对象： 
1、冰箱门可以被打开
2、大象可以被塞进冰箱里
3、冰箱门可以被关闭

孙全
孙全  1
孙全  2
孙全  3

翟盼盼
翟 	1
翟  2
翟  3

面向对象：意在写出一个通用的代码，屏蔽差异。


关门
面向过程：关门
张三 一脚把门踹紧了
李四 轻轻的把门带上了
王五 门没关严，留了个尾巴

面向对象：关门
门可以被关闭

我在黑板上画了一个零星
将 圆圈作为对象
圆圈可以被画在黑板上



将 黑板作为对象
黑板可以被画圆




我在黑板上画了一个圆
张三上来的  哪尺子比这画了一个特别圆的圆
李四上来的 随便一划拉
王五上来了  圆规画了一个圆
圆可以被画在黑板上
圆圈可以被画在黑板上
将圆圈作为对象：这个圆圈可以被画在黑板上。
黑板可以被画圆
黑板作为一个对象：可以被画圆圈  被画方块 被画正方向


试着描述孙全和颜XX的特征和行为
姓名：孙全
性别：男
身高：180cm
体重：70kg
年龄：22岁
吃喝拉撒睡一切正常 健康
吃喝嫖赌抽

姓名：颜XX
性别：男
身高：180cm
体重：70KG
年龄：23岁
脑残 身体一切健康


我们在代码中描述一个对象，通过描述这个对象的属性和方法
对象必须是看得见摸得着的

灯：属性和方法
属性：
外形：长的
亮度：500W
颜色：白色
牌子：XX
方法：发光


电风扇：属性、方法
外形：三个扇叶
颜色：白色
品牌：XX
方法：转动，扇风


我们把这些具有相同属性和相同方法的对象进行进一步的封装，抽象出来 类这个概念。
类就是个模子，确定了对象应该具有的属性和方法。
对象是根据类创建出来的。
类就是一个盖大楼的图纸   对象 就是盖出来的大楼。

2、类
语法：
[public] class 类名
{
	字段;
	属性;//属性的默认访问修饰符为private
	方法;
}
写好了一个类之后，我们需要创建这个类的对象，
那么，我们管创建这个类的对象过程称之为类的实例化。
使用关键字 new.

this:表示当前这个类的对象。
类是不占内存的，而对象是占内存的。

与结构的区别，结构不具备封装,继承,多态等面向对象的特征


3、属性
属性的作用就是保护字段、对字段的赋值和取值进行限定。
属性的本质就是两个方法，一个叫get()一个叫set()。
既有get()也有set()我们诚之为可读可写属性。
只有get()没有set()我们称之为只读属性
没有get()只有set()我们称之为只写属性

Field字段
Method方法
Property属性

****字段就是女人  属性才是男人。

4、访问修饰符
public：公开的公共的，在哪都能访问。
private：私有的，只能在当前类的内部进行访问，出了这个类就访问不到了。

5、
当我们创建好一个类的对象后，需要给这个对象的每个属性去赋值。
我们管这个过程称之为对象的初始化。

6、静态和非静态的区别
1)、在非静态类中，既可以有实例成员，也可以有静态成员。
2)、在调用实例成员的时候，需要使用对象名.实例成员;
    在调用静态成员的时候，需要使用类名.静态成员名;
总结：静态成员必须使用类名去调用，而实例成员使用对象名调用。
	  静态函数中，只能访问静态成员，不允许访问实例成员。
      实例函数中，既可以使用静态成员，也可以使用实例成员。
      静态类中只允许有静态成员，不允许出现实例成员。
	  
	  静态类不允许被实例化

使用：
1)、如果你想要你的类当做一个"工具类"去使用，这个时候可以考虑将类写成静态的。
2)、静态类在整个项目中资源共享。
只有在程序全部结束之后，静态类才会释放资源。


堆  栈  静态存储区域

释放资源。GC Garbage Collection垃圾回收器


7、构造函数
作用：帮助我们初始化对象(给对象的每个属性依次的赋值)
构造函数是一个特殊的方法：
1)、构造函数没有返回值，连void也不能写。
2)、构造函数的名称必须跟类名一样。

创建对象的时候会执行构造函数
构造函数是可以有重载的。
***
类当中会有一个默认的无参数的构造函数，当你写一个新的构造函数之后，不管是有参数的还是
无参数的，那个默认的无参数的构造函数都被干掉了。如果还要用无参构造函数，需要自己重写一个无参构造函数

8、new关键字
Person zsPerson=new Person();
new帮助我们做了3件事儿：
1)、在内存中开辟一块空间
2)、在开辟的空间中创建对象
3)、调用对象的构造函数进行初始化对象

9、this关键字
1)、代表当前类的对象
2)、在类当中显示的调用本类的构造函数  :this

1、命名空间
可以认为类是属于命名空间的。
如果在当前项目中没有这个类的命名空间，需要我们手动的导入这个类所在的
命名空间。
1)、用鼠标去点
2)、alt+shift+F10
3)、记住命名空间，手动的去引用

2、在一个项目中引用另一个项目的类
1)、添加引用
2)、引用命名空间

3、值类型和引用类型
区别：
1、值类型和引用类型在内存上存储的地方不一样。
2、在传递值类型和传递引用类型的时候，传递的方式不一样。
值类型我们称之为值传递，引用类型我们称之为引用传递。
我们学的值类型和引用类型：
值类型：int、double、bool、char、decimal、struct、enum
引用类型：string、自定义类、数组
存储：
值类型的值是存储在内存的栈当中。
引用类型的值是存储在内存的堆中。

3、字符串
1)、字符串的不可变性
当你给一个字符串重新赋值之后，老值并没有销毁，而是重新开辟一块空间存储新值。

当程序结束后，GC扫描整个内存，如果发现有的空间没有被指向，则立即把它销毁。


2)、我们可以讲字符串看做是char类型的一个只读数组。
ToCharArray();将字符串转换为char数组
new string(char[] chs):能够将char数组转换为字符串

4、字符串提供的各种方法
1)、Length：获得当前字符串中字符的个数
2)、ToUpper():将字符转换成大写形式
3)、ToLower():将字符串转换成小写形式
4)、Equals(lessonTwo,StringComparison.OrdinalIgnoreCase):比较两个字符串，可以忽略大小写
5)、Split()：分割字符串，返回字符串类型的数组。
6)、Substring()：解决字符串。在截取的时候包含要截取的那个位置。
7)、IndexOf():判断某个字符串在字符串中第一次出现的位置，如果没有返回-1、值类型和引用类型在内存上存储的地方不一样。
8)、LastIndexOf()：判断某个字符串在字符串中最后一次出现的位置，如果没有同样返回-1
9)、StartsWith():判断以....开始
10)、EndsWith():判断以...结束
11)、Replace():将字符串中某个字符串替换成一个新的字符串
12)、Contains():判断某个字符串是否包含指定的字符串
13)、Trim():去掉字符串中前后的空格
14)、TrimEnd()：去掉字符串中结尾的空格
15)、TrimStart()：去掉字符串中前面的空格
16)、string.IsNullOrEmpty():判断一个字符串是否为空或者为null
17)、string.Join()：将数组按照指定的字符串连接，返回一个字符串。


5、继承
我们可能会在一些类中，写一些重复的成员，我们可以将这些重复的成员，
单独的封装到一个类中，作为这些类的父类。
Student、Teacher、Driver  子类  派生类
Person   				  父类  基类
子类继承了父类，那么子类从父类那里继承过来了什么？
首先，子类继承了父类的属性和方法，但是子类并没有继承父类的私有字段。
问题：子类有没有继承父类的构造函数？
答：子类并没有继承父类的构造函数，但是。子类会默认的调用父类无参数的构造函数，
创建父类对象，让子类可以使用父类中的成员。
所以，如果在父类中重新写了一个有参数的构造函数之后，那个无参数的就被干掉了，
子类就调用不到了，所以子类会报错。
解决办法：
1)、在父类中重新写一个无参数的构造函数。
2)、在子类中显示的调用父类的构造函数，使用关键字:base()



6、继承的特性
1、继承的单根性：一个子类只能有一个父类。
2、继承的传递性

7、查看类图

8、Object是所有类的基类。若类没有继承其他类则默认继承Object


9、new关键字
1)、创建对象
2)、隐藏从父类那里继承过来的同名成员。
隐藏的后果就是子类调用不到父类的成员。

1、里氏转换
1)、子类可以赋值给父类
2)、如果父类中装的是子类对象，那么可以讲这个父类强转为子类对象。

2、
子类对象可以调用父类中的成员，但是父类对象永远都只能调用自己的成员。


3、
is：表示类型转换，如果能够转换成功，则返回一个true，否则返回一个false
as：表示类型转换，如果能够转换则返回对应的对象，否则返回一个null

4、protected
受保护的：可以在当前类的内部以及该类的子类中访问。

============集合===========
5、ArrayList集合的长度问题
每次集合中实际包含的元素个数(count)超过了可以包含的元素的个数(capcity)的时候，
集合就会向内存中申请多开辟一倍的空间，来保证集合的长度一直够用。

6、Hastable 键值对集合  字典  孙    sun---孙  
在键值对集合当中，我们是根据键去找值的。
键值对对象[键]=值;
*****:键值对集合当中，键必须是唯一的，而值是可以重复的
7、foreach循环



8、编码格式
产生乱码的原因就是因为你保存这个文件的编码格式跟你打开这个文件的编码格式不一样。


9、文本文件
拖到txt文件中，还能看得懂的文件就是文本文件。

1、绝对路径和相对路径
绝对路径：通过给定的这个路径直接能在我的电脑中找到这个文件。
相对路径：文件相对于应用程序的路径。
结论：
我们在开发中应该去尽量的使用相对路径。


2、装箱、拆箱
装箱：就是将值类型转换为引用类型。
拆箱：将引用类型转换为值类型。
看两种类型是否发生了装箱或者拆箱，要看，这两种类型是否存在继承关系。


3、将创建文件流对象的过程写在using当中，会自动的帮助我们释放流所占用的资源。

4、实现多态的手段
1)、虚方法
步骤：
1、将父类的方法标记为虚方法 ，使用关键字 virtual，这个函数可以被子类重新写一个遍。


2)、抽象类
当父类中的方法不知道如何去实现的时候，可以考虑将父类写成抽象类，将方法写成抽象方法。

1.抽象成员必须标记为abstract,并且不能有任何实现。
2.抽象成员必须在抽象类中。
3.抽象类不能被实例化

4.子类继承抽象类后，必须把父类中的所有抽象成员都重写。

（除非子类也是一个抽象类，则可以不重写）
5.抽象成员的访问修饰符不能是private
6.在抽象类中可以包含实例成员。
并且抽象类的实例成员可以不被子类实现

7.抽象类是有构造函数的。虽然不能被实例化。


8、如果父类的抽象方法中有参数，那么。继承这个抽象父类的子类在重写父类的方法的时候必须传入对应的参数。

如果抽象父类的抽象方法中有返回值，那么子类在重写这个抽象方法的时候 也必须要传入返回值。


======
如果父类中的方法有默认的实现，并且父类需要被实例化，这时可以考虑将父类定义成一个普通类，用虚方法来实现多态。

如果父类中的方法没有默认实现，父类也不需要被实例化，则可以将该类定义为抽象类。

1、c#中的访问修饰符
public :公开的公共的
private：私有的，只能在当前类的内部访问
protected：受保护的，只能在当前类的内部以及该类的子类中访问。
internal：只能在当前项目中访问。在同一个项目中，internal和public的权限是一样。
protected internal：protected+internal

1)、能够修饰类的访问修饰符只有两个：public、internal。
2)、可访问性不一致。
子类的访问权限不能高于父类的访问权限，会暴漏父类的成员。


2、设计模式
设计这个项目的一种方式。

3、简单工厂设计模式

4、值类型在复制的时候，传递的是这个值得本身。
   引用类型在复制的时候，传递的是对这个对象的引用。
   
5、序列化：就是将对象转换为二进制
   反序列化：就是将二进制转换为对象
   作用：传输数据。
  序列化：
  1)、将这个类标记为可以被序列化的。
  
  
6、partial部分类

7、sealed密封类 
不能够被其他类继承，但是可以继承于其他类。
 

8、接口
[public] interface I..able
{
	成员;
}

接口是一种规范。
只要一个类继承了一个接口，这个类就必须实现这个接口中所有的成员

为了多态。
接口不能被实例化。
也就是说，接口不能new(不能创建对象)





接口中的成员不能加“访问修饰符”，接口中的成员访问修饰符为public,不能修改。


（默认为public）
接口中的成员不能有任何实现（“光说不做”，只是定义了一组未实现的成员）。



接口中只能有方法、属性、索引器、事件，不能有“字段”和构造函数。

接口与接口之间可以继承，并且可以多继承。

接口并不能去继承一个类，而类可以继承接口  （接口只能继承于接口，而类既可以继承接口，也可以继承类）


实现接口的子类必须实现该接口的全部成员。


一个类可以同时继承一个类并实现多个接口，如果一个子类同时继承了父类A，并实现了接口IA,那么语法上A必须写在IA的前面。

class MyClass:A,IA{}，因为类是单继承的。

显示实现接口的目的：解决方法的重名问题
什么时候显示的去实现接口：
当继承的借口中的方法和参数一摸一样的时候，要是用显示的实现接口


当一个抽象类实现接口的时候，需要子类去实现接口。

===WinForm===
1、winform应用程序是一种智能客户端技术，我们可以使用winform应用程序
帮助我们获得信息或者传输信息等。

2、属性
Name：在后台要获得前台的控件对象，需要使用Name属性。
visible：指示一个控件是否可见。
Enabled：指示一个控件是否可用。

3、事件：发生一件事情。
注册事件：双击控件注册的都是控件默认被选中的那个事件。
触发事件:

4、
在Main函数当中创建的窗体对象，我们称之为这个窗体应用程序的主窗体。
也就意味着，当你将主窗体关闭后，整个应用程序都关闭了。

5、TextBox控件
WordWrap:指示文本框是否换行。
PasswordChar：让文本框显示一个单一的字符
ScollBars：是否显示滚动条
事件：TextChanged 当文本框中的内容发生改变的时候触发这个事件。

6、跑马灯练习
abcde
bcdea
string str="abcde";
		str=str.Substring(1)+str.Substring(0,1);


cdeab
deabc
eabcd
abcde


7、Timer
在指定的时间间隔内做一件指定的事情。


8、简单记事儿本应用程序
1)、在程序加载的时候，取消文本框的自动换行，以及让两个按钮和文本框隐藏
2)、点击登陆，判断是否登陆成功
3)、自动换行功能
4)、保存文本到一个指定目录下。


9、单选和多选
checked：指示这个控件是否处于选中状态。

默认情况下，在一个窗体中，所有的单选按钮只允许选中一个，可以使用groupbox进行分组。

10、MDI窗体的设计
1、首先确定一个父窗体。 将IsMdiContainer设置为true。
2、创建子窗体，并且设置他们的父窗体。

1、Directory 操作文件夹
CreateDirectory 创建文件夹
Delete  删除文件夹
Move  剪切文件夹
Exist  判断是否存在
GetFiles 获得指定的目录下所有文件的全路径
GetDirectory 获得指定目录下所有文件夹的全路径


2、WebBrowser浏览器控件
url

3、ComboBox下拉框控件
DropDownStyle：控制下拉框的外观样式
名字：cbo+....
案例：日期选择器


4、点击更换图片
1)、在程序加载的时候，将指定图片文件夹中所有的图片文件名读取到ListBox中



5、石头剪刀布
石头 1   剪刀 2 布  3
玩家赢了：  1 2=-1   2 3=-1  3  1=2 
平手：   相减 =0
另外一种情况 ：电脑赢了

6、对话框

7、进程
我们可以把计算机中每一个运行的应用程序都当做是一个进程。
而一个进程又是由多个线程组成的。


8、单线程给我们带来的问题

9、在.Net下，是不允许跨线程的访问。

MessageBox.Show()的各种用法  


【函数】 <整型> MessageBox（<字符串> Text, <字符串> Title, <整型> nType，MessageBoxIcon）;

【函数说明】 弹出一个消息框。

【语法】

参数：

Text <字符串>，消息框的正文；

Title <字符串>，消息框的标题；

nType <整型>，消息框的类型。

返回值：<整型>，用户在消息框上点击关闭时的选择的按钮。 MessageBoxIcon：对话框上显示的图标样式。

【说明】

MessageBox("消息内容", "返回值 确定1",MessageBoxButtons.OK,MessageBoxIcon.Question);

MessageBox("消息内容",, "返回值 确定1 取消2",MessageBoxButtons.OKCancel, MessageBoxIcon.Asterisk);

MessageBox("消息内容", "返回值 终止3 重试4 忽略5",MessageBoxButtons.AbortRetryIgnore, MessageBoxIcon.Error);

MessageBox("消息内容", "返回值 是6 否7 取消2",MessageBoxButtons.YesNoCancel, MessageBoxIcon.Exclamation);

MessageBox("消息内容", "返回值 是6 否7",MessageBoxButtons.YesNo, MessageBoxIcon.Hand);

MessageBox("消息内容", "返回值 重试4 取消2",MessageBoxButtons.RetryCancel, MessageBoxIcon.Information);

MessageBoxIcon: 所有图标样式

MessageBoxIcon.Question

MessageBoxIcon.Asterisk

MessageBoxIcon.Information

MessageBoxIcon.Error

MessageBoxIcon.Stop

MessageBoxIcon.Hand

MessageBoxIcon.Exclamation

MessageBoxIcon.Warning

MessageBoxIcon.None




















  
   
   
   










































































































































